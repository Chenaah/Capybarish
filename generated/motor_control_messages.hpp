/**
 * @file Auto-generated message definitions for motor_control
 *
 * Generated from: schemas/motor_control.cpy
 * Generated at: 2026-01-02T14:42:33.641359
 *
 * DO NOT EDIT - This file is auto-generated by capybarish-gen.
 *
 * @copyright 2025 Chen Yu
 * @license Apache-2.0
 */

#ifndef MOTOR_CONTROL_MESSAGES_HPP
#define MOTOR_CONTROL_MESSAGES_HPP

#include <cstdint>
#include <cstring>

#ifdef ARDUINO
#include <Arduino.h>
#endif

namespace motor_control {

// Forward declarations
struct MotorCommand;
struct IMUOrientation;
struct IMUQuaternion;
struct IMUOmega;
struct IMUAcceleration;
struct IMUData;
struct MotorData;
struct ErrorData;
struct SensorData;

/** Motor command sent from server to robot module */
#pragma pack(push, 1)
struct MotorCommand {
    float target = 0.0f;  ///< Target position (radians)
    float target_vel = 0.0f;  ///< Target velocity (rad/s)
    float kp = 0.0f;  ///< Proportional gain
    float kd = 0.0f;  ///< Derivative gain
    int32_t enable_filter = 0;  ///< Enable low-pass filter (0 or 1)
    int32_t switch_ = 0;  ///< Motor switch state (0=off, 1=on)
    int32_t calibrate = 0;  ///< Trigger calibration (0 or 1)
    int32_t restart = 0;  ///< Trigger restart (0 or 1)
    float timestamp = 0.0f;  ///< Command timestamp (seconds)

    static constexpr size_t SIZE = 36;

    /**
     * @brief Serialize struct to byte buffer
     * @param buffer Output buffer (must be at least SIZE bytes)
     */
    void serialize(uint8_t* buffer) const {
        memcpy(buffer, this, SIZE);
    }

    /**
     * @brief Deserialize from byte buffer
     * @param buffer Input buffer (must be at least SIZE bytes)
     * @param len Buffer length
     * @return true if successful
     */
    bool deserialize(const uint8_t* buffer, size_t len) {
        if (len < SIZE) return false;
        memcpy(this, buffer, SIZE);
        return true;
    }

    /**
     * @brief Static factory: create from byte buffer
     * @param buffer Input buffer
     * @param len Buffer length
     * @return MotorCommand object
     */
    static MotorCommand fromBytes(const uint8_t* buffer, size_t len) {
        MotorCommand obj;
        obj.deserialize(buffer, len);
        return obj;
    }
};
#pragma pack(pop)
static_assert(sizeof(MotorCommand) == 36, "Size mismatch for MotorCommand");

/** IMU orientation (Euler angles in radians) */
#pragma pack(push, 1)
struct IMUOrientation {
    float x = 0.0f;  ///< Roll
    float y = 0.0f;  ///< Pitch
    float z = 0.0f;  ///< Yaw

    static constexpr size_t SIZE = 12;

    /**
     * @brief Serialize struct to byte buffer
     * @param buffer Output buffer (must be at least SIZE bytes)
     */
    void serialize(uint8_t* buffer) const {
        memcpy(buffer, this, SIZE);
    }

    /**
     * @brief Deserialize from byte buffer
     * @param buffer Input buffer (must be at least SIZE bytes)
     * @param len Buffer length
     * @return true if successful
     */
    bool deserialize(const uint8_t* buffer, size_t len) {
        if (len < SIZE) return false;
        memcpy(this, buffer, SIZE);
        return true;
    }

    /**
     * @brief Static factory: create from byte buffer
     * @param buffer Input buffer
     * @param len Buffer length
     * @return IMUOrientation object
     */
    static IMUOrientation fromBytes(const uint8_t* buffer, size_t len) {
        IMUOrientation obj;
        obj.deserialize(buffer, len);
        return obj;
    }
};
#pragma pack(pop)
static_assert(sizeof(IMUOrientation) == 12, "Size mismatch for IMUOrientation");

/** IMU quaternion representation */
#pragma pack(push, 1)
struct IMUQuaternion {
    float x = 0.0f;
    float y = 0.0f;
    float z = 0.0f;
    float w = 0.0f;

    static constexpr size_t SIZE = 16;

    /**
     * @brief Serialize struct to byte buffer
     * @param buffer Output buffer (must be at least SIZE bytes)
     */
    void serialize(uint8_t* buffer) const {
        memcpy(buffer, this, SIZE);
    }

    /**
     * @brief Deserialize from byte buffer
     * @param buffer Input buffer (must be at least SIZE bytes)
     * @param len Buffer length
     * @return true if successful
     */
    bool deserialize(const uint8_t* buffer, size_t len) {
        if (len < SIZE) return false;
        memcpy(this, buffer, SIZE);
        return true;
    }

    /**
     * @brief Static factory: create from byte buffer
     * @param buffer Input buffer
     * @param len Buffer length
     * @return IMUQuaternion object
     */
    static IMUQuaternion fromBytes(const uint8_t* buffer, size_t len) {
        IMUQuaternion obj;
        obj.deserialize(buffer, len);
        return obj;
    }
};
#pragma pack(pop)
static_assert(sizeof(IMUQuaternion) == 16, "Size mismatch for IMUQuaternion");

/** IMU angular velocity (rad/s) */
#pragma pack(push, 1)
struct IMUOmega {
    float x = 0.0f;
    float y = 0.0f;
    float z = 0.0f;

    static constexpr size_t SIZE = 12;

    /**
     * @brief Serialize struct to byte buffer
     * @param buffer Output buffer (must be at least SIZE bytes)
     */
    void serialize(uint8_t* buffer) const {
        memcpy(buffer, this, SIZE);
    }

    /**
     * @brief Deserialize from byte buffer
     * @param buffer Input buffer (must be at least SIZE bytes)
     * @param len Buffer length
     * @return true if successful
     */
    bool deserialize(const uint8_t* buffer, size_t len) {
        if (len < SIZE) return false;
        memcpy(this, buffer, SIZE);
        return true;
    }

    /**
     * @brief Static factory: create from byte buffer
     * @param buffer Input buffer
     * @param len Buffer length
     * @return IMUOmega object
     */
    static IMUOmega fromBytes(const uint8_t* buffer, size_t len) {
        IMUOmega obj;
        obj.deserialize(buffer, len);
        return obj;
    }
};
#pragma pack(pop)
static_assert(sizeof(IMUOmega) == 12, "Size mismatch for IMUOmega");

/** IMU linear acceleration (m/s²) */
#pragma pack(push, 1)
struct IMUAcceleration {
    float x = 0.0f;
    float y = 0.0f;
    float z = 0.0f;

    static constexpr size_t SIZE = 12;

    /**
     * @brief Serialize struct to byte buffer
     * @param buffer Output buffer (must be at least SIZE bytes)
     */
    void serialize(uint8_t* buffer) const {
        memcpy(buffer, this, SIZE);
    }

    /**
     * @brief Deserialize from byte buffer
     * @param buffer Input buffer (must be at least SIZE bytes)
     * @param len Buffer length
     * @return true if successful
     */
    bool deserialize(const uint8_t* buffer, size_t len) {
        if (len < SIZE) return false;
        memcpy(this, buffer, SIZE);
        return true;
    }

    /**
     * @brief Static factory: create from byte buffer
     * @param buffer Input buffer
     * @param len Buffer length
     * @return IMUAcceleration object
     */
    static IMUAcceleration fromBytes(const uint8_t* buffer, size_t len) {
        IMUAcceleration obj;
        obj.deserialize(buffer, len);
        return obj;
    }
};
#pragma pack(pop)
static_assert(sizeof(IMUAcceleration) == 12, "Size mismatch for IMUAcceleration");

/** Complete IMU data package */
#pragma pack(push, 1)
struct IMUData {
    IMUOrientation orientation;
    IMUQuaternion quaternion;
    IMUOmega omega;
    IMUAcceleration acceleration;

    static constexpr size_t SIZE = 52;

    /**
     * @brief Serialize struct to byte buffer
     * @param buffer Output buffer (must be at least SIZE bytes)
     */
    void serialize(uint8_t* buffer) const {
        memcpy(buffer, this, SIZE);
    }

    /**
     * @brief Deserialize from byte buffer
     * @param buffer Input buffer (must be at least SIZE bytes)
     * @param len Buffer length
     * @return true if successful
     */
    bool deserialize(const uint8_t* buffer, size_t len) {
        if (len < SIZE) return false;
        memcpy(this, buffer, SIZE);
        return true;
    }

    /**
     * @brief Static factory: create from byte buffer
     * @param buffer Input buffer
     * @param len Buffer length
     * @return IMUData object
     */
    static IMUData fromBytes(const uint8_t* buffer, size_t len) {
        IMUData obj;
        obj.deserialize(buffer, len);
        return obj;
    }
};
#pragma pack(pop)
static_assert(sizeof(IMUData) == 52, "Size mismatch for IMUData");

/** Motor sensor data */
#pragma pack(push, 1)
struct MotorData {
    float pos = 0.0f;  ///< Current position (radians)
    float large_pos = 0.0f;  ///< Unwrapped position (radians)
    float vel = 0.0f;  ///< Current velocity (rad/s)
    float torque = 0.0f;  ///< Current torque (Nm)
    float voltage = 0.0f;  ///< Motor voltage (V)
    float current = 0.0f;  ///< Motor current (A)
    int32_t temperature = 0;  ///< Temperature (°C)
    int32_t error0 = 0;  ///< Error code 0 (mode & error)
    int32_t error1 = 0;  ///< Error code 1

    static constexpr size_t SIZE = 36;

    /**
     * @brief Serialize struct to byte buffer
     * @param buffer Output buffer (must be at least SIZE bytes)
     */
    void serialize(uint8_t* buffer) const {
        memcpy(buffer, this, SIZE);
    }

    /**
     * @brief Deserialize from byte buffer
     * @param buffer Input buffer (must be at least SIZE bytes)
     * @param len Buffer length
     * @return true if successful
     */
    bool deserialize(const uint8_t* buffer, size_t len) {
        if (len < SIZE) return false;
        memcpy(this, buffer, SIZE);
        return true;
    }

    /**
     * @brief Static factory: create from byte buffer
     * @param buffer Input buffer
     * @param len Buffer length
     * @return MotorData object
     */
    static MotorData fromBytes(const uint8_t* buffer, size_t len) {
        MotorData obj;
        obj.deserialize(buffer, len);
        return obj;
    }
};
#pragma pack(pop)
static_assert(sizeof(MotorData) == 36, "Size mismatch for MotorData");

/** System error data */
#pragma pack(push, 1)
struct ErrorData {
    int32_t reset_reason0 = 0;  ///< CPU0 reset reason
    int32_t reset_reason1 = 0;  ///< CPU1 reset reason

    static constexpr size_t SIZE = 8;

    /**
     * @brief Serialize struct to byte buffer
     * @param buffer Output buffer (must be at least SIZE bytes)
     */
    void serialize(uint8_t* buffer) const {
        memcpy(buffer, this, SIZE);
    }

    /**
     * @brief Deserialize from byte buffer
     * @param buffer Input buffer (must be at least SIZE bytes)
     * @param len Buffer length
     * @return true if successful
     */
    bool deserialize(const uint8_t* buffer, size_t len) {
        if (len < SIZE) return false;
        memcpy(this, buffer, SIZE);
        return true;
    }

    /**
     * @brief Static factory: create from byte buffer
     * @param buffer Input buffer
     * @param len Buffer length
     * @return ErrorData object
     */
    static ErrorData fromBytes(const uint8_t* buffer, size_t len) {
        ErrorData obj;
        obj.deserialize(buffer, len);
        return obj;
    }
};
#pragma pack(pop)
static_assert(sizeof(ErrorData) == 8, "Size mismatch for ErrorData");

/** Complete sensor data from robot module */
#pragma pack(push, 1)
struct SensorData {
    int32_t module_id = 0;  ///< Unique module identifier
    int32_t receive_dt = 0;  ///< Receive processing time (µs)
    int32_t timestamp = 0;  ///< Current timestamp (µs)
    int32_t switch_off = 0;  ///< Switch off request flag
    float last_rcv_timestamp = 0.0f;  ///< Last received command timestamp
    int32_t info = 0;  ///< Info/status code
    MotorData motor;  ///< Motor sensor data
    IMUData imu;  ///< IMU sensor data
    ErrorData error;  ///< Error/reset data
    float goal_distance = 0.0f;  ///< Distance to goal (meters)

    static constexpr size_t SIZE = 124;

    /**
     * @brief Serialize struct to byte buffer
     * @param buffer Output buffer (must be at least SIZE bytes)
     */
    void serialize(uint8_t* buffer) const {
        memcpy(buffer, this, SIZE);
    }

    /**
     * @brief Deserialize from byte buffer
     * @param buffer Input buffer (must be at least SIZE bytes)
     * @param len Buffer length
     * @return true if successful
     */
    bool deserialize(const uint8_t* buffer, size_t len) {
        if (len < SIZE) return false;
        memcpy(this, buffer, SIZE);
        return true;
    }

    /**
     * @brief Static factory: create from byte buffer
     * @param buffer Input buffer
     * @param len Buffer length
     * @return SensorData object
     */
    static SensorData fromBytes(const uint8_t* buffer, size_t len) {
        SensorData obj;
        obj.deserialize(buffer, len);
        return obj;
    }
};
#pragma pack(pop)
static_assert(sizeof(SensorData) == 124, "Size mismatch for SensorData");

} // namespace motor_control

#endif // MOTOR_CONTROL_MESSAGES_HPP