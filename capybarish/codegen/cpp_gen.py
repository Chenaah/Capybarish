"""
C++ Code Generator for Capybarish schemas.

Generates C++ struct definitions with serialization support from .cpy schema files,
compatible with Arduino/ESP32.

Copyright 2025 Chen Yu <chenyu@u.northwestern.edu>

Licensed under the Apache License, Version 2.0.
"""

from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

from .parser import FieldDef, FieldType, MessageDef, SchemaDef, SchemaParser


class CppGenerator:
    """Generates C++ code from Capybarish schema definitions."""
    
    # C++ type names for each field type
    CPP_TYPES = {
        FieldType.INT8: "int8_t",
        FieldType.INT16: "int16_t",
        FieldType.INT32: "int32_t",
        FieldType.INT64: "int64_t",
        FieldType.UINT8: "uint8_t",
        FieldType.UINT16: "uint16_t",
        FieldType.UINT32: "uint32_t",
        FieldType.UINT64: "uint64_t",
        FieldType.FLOAT32: "float",
        FieldType.FLOAT64: "double",
        FieldType.FLOAT: "float",
        FieldType.DOUBLE: "double",
        FieldType.INT: "int32_t",
        FieldType.BOOL: "bool",
        FieldType.BYTE: "uint8_t",
        FieldType.CHAR: "char",
    }
    
    # Default initializers
    DEFAULT_VALUES = {
        FieldType.INT8: "0",
        FieldType.INT16: "0",
        FieldType.INT32: "0",
        FieldType.INT64: "0",
        FieldType.UINT8: "0",
        FieldType.UINT16: "0",
        FieldType.UINT32: "0",
        FieldType.UINT64: "0",
        FieldType.FLOAT32: "0.0f",
        FieldType.FLOAT64: "0.0",
        FieldType.FLOAT: "0.0f",
        FieldType.DOUBLE: "0.0",
        FieldType.INT: "0",
        FieldType.BOOL: "false",
        FieldType.BYTE: "0",
        FieldType.CHAR: "'\\0'",
    }
    
    def __init__(self, schema: SchemaDef):
        self.schema = schema
        self.parser = SchemaParser()
    
    def generate_header(self) -> str:
        """Generate C++ header file."""
        lines = []
        
        # File header comment
        lines.extend(self._generate_file_header())
        lines.append("")
        
        # Include guard
        guard_name = self._get_guard_name()
        lines.append(f"#ifndef {guard_name}")
        lines.append(f"#define {guard_name}")
        lines.append("")
        
        # Includes
        lines.extend(self._generate_includes())
        lines.append("")
        
        # Namespace
        namespace = self.schema.package or "capybarish"
        lines.append(f"namespace {namespace} {{")
        lines.append("")
        
        # Get messages in dependency order
        msg_order = self.parser.get_dependency_order(self.schema)
        
        # Forward declarations
        lines.append("// Forward declarations")
        for msg_name in msg_order:
            lines.append(f"struct {msg_name};")
        lines.append("")
        
        # Generate structs
        for msg_name in msg_order:
            msg = self.schema.messages[msg_name]
            lines.extend(self._generate_struct(msg))
            lines.append("")
        
        # Close namespace
        lines.append(f"}} // namespace {namespace}")
        lines.append("")
        
        # Close include guard
        lines.append(f"#endif // {guard_name}")
        
        return "\n".join(lines)
    
    def generate_source(self) -> str:
        """Generate C++ source file (if needed for complex operations)."""
        # For simple POD structs, all code is in the header
        # This is here for future expansion
        lines = []
        lines.extend(self._generate_file_header())
        lines.append("")
        
        header_name = self._get_header_filename()
        lines.append(f'#include "{header_name}"')
        lines.append("")
        
        namespace = self.schema.package or "capybarish"
        lines.append(f"namespace {namespace} {{")
        lines.append("")
        lines.append("// Implementation details (if any)")
        lines.append("")
        lines.append(f"}} // namespace {namespace}")
        
        return "\n".join(lines)
    
    def _generate_file_header(self) -> List[str]:
        """Generate file header comment."""
        package_name = self.schema.package or "messages"
        source = self.schema.source_file or "schema"
        
        return [
            "/**",
            f" * @file Auto-generated message definitions for {package_name}",
            " *",
            f" * Generated from: {source}",
            f" * Generated at: {datetime.now().isoformat()}",
            " *",
            " * DO NOT EDIT - This file is auto-generated by capybarish-gen.",
            " *",
            " * @copyright 2025 Chen Yu",
            " * @license Apache-2.0",
            " */",
        ]
    
    def _generate_includes(self) -> List[str]:
        """Generate include statements."""
        return [
            "#include <cstdint>",
            "#include <cstring>",
            "",
            "#ifdef ARDUINO",
            "#include <Arduino.h>",
            "#endif",
        ]
    
    def _get_guard_name(self) -> str:
        """Generate include guard name."""
        package = self.schema.package or "capybarish"
        return f"{package.upper()}_MESSAGES_HPP"
    
    def _get_header_filename(self) -> str:
        """Generate header filename."""
        package = self.schema.package or "messages"
        return f"{package}_messages.hpp"
    
    def _generate_struct(self, msg: MessageDef) -> List[str]:
        """Generate a C++ struct for a message."""
        lines = []
        msg_size = msg.get_size(self.schema.messages)
        
        # Comment
        if msg.comment:
            lines.append(f"/** {msg.comment} */")
        
        # Use #pragma pack for consistent memory layout across platforms
        lines.append("#pragma pack(push, 1)")
        lines.append(f"struct {msg.name} {{")
        
        # Fields
        for f in msg.fields:
            lines.extend(self._generate_field(f))
        
        lines.append("")
        
        # Static size constant
        lines.append(f"    static constexpr size_t SIZE = {msg_size};")
        lines.append("")
        
        # Serialize method
        lines.extend(self._generate_serialize_method(msg))
        lines.append("")
        
        # Deserialize method
        lines.extend(self._generate_deserialize_method(msg))
        
        lines.append("};")
        lines.append("#pragma pack(pop)")
        
        # Static assert to verify size
        lines.append(f"static_assert(sizeof({msg.name}) == {msg_size}, \"Size mismatch for {msg.name}\");")
        
        return lines
    
    def _generate_field(self, f: FieldDef) -> List[str]:
        """Generate a field definition."""
        lines = []
        
        if f.is_nested:
            type_name = f.type_name
        else:
            type_name = self.CPP_TYPES[f.field_type]
        
        if f.is_array:
            field_decl = f"    {type_name} {f.name}[{f.array_size}]"
        else:
            field_decl = f"    {type_name} {f.name}"
        
        # Add default initializer for non-nested scalar types
        if not f.is_nested and not f.is_array:
            default = self.DEFAULT_VALUES.get(f.field_type, "")
            if default:
                field_decl += f" = {default}"
        
        comment = f"  ///< {f.comment}" if f.comment else ""
        lines.append(f"{field_decl};{comment}")
        
        return lines
    
    def _generate_serialize_method(self, msg: MessageDef) -> List[str]:
        """Generate serialize method."""
        return [
            "    /**",
            "     * @brief Serialize struct to byte buffer",
            "     * @param buffer Output buffer (must be at least SIZE bytes)",
            "     */",
            "    void serialize(uint8_t* buffer) const {",
            "        memcpy(buffer, this, SIZE);",
            "    }",
        ]
    
    def _generate_deserialize_method(self, msg: MessageDef) -> List[str]:
        """Generate deserialize method."""
        return [
            "    /**",
            "     * @brief Deserialize from byte buffer",
            "     * @param buffer Input buffer (must be at least SIZE bytes)",
            "     * @return true if successful",
            "     */",
            "    bool deserialize(const uint8_t* buffer, size_t len) {",
            "        if (len < SIZE) return false;",
            "        memcpy(this, buffer, SIZE);",
            "        return true;",
            "    }",
        ]
    
    def write_header(self, output_path: str) -> None:
        """Generate and write C++ header to file."""
        content = self.generate_header()
        path = Path(output_path)
        path.parent.mkdir(parents=True, exist_ok=True)
        with open(path, "w") as f:
            f.write(content)
    
    def write_source(self, output_path: str) -> None:
        """Generate and write C++ source to file."""
        content = self.generate_source()
        path = Path(output_path)
        path.parent.mkdir(parents=True, exist_ok=True)
        with open(path, "w") as f:
            f.write(content)


def generate_cpp(schema: SchemaDef, output_dir: str, header_only: bool = True) -> None:
    """Convenience function to generate C++ code from schema."""
    generator = CppGenerator(schema)
    
    package = schema.package or "messages"
    header_path = Path(output_dir) / f"{package}_messages.hpp"
    generator.write_header(str(header_path))
    
    if not header_only:
        source_path = Path(output_dir) / f"{package}_messages.cpp"
        generator.write_source(str(source_path))
