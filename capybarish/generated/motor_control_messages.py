"""
Auto-generated message definitions for motor_control.

Generated from: schemas/motor_control.cpy
Generated at: 2025-12-08T02:24:12.303077

DO NOT EDIT - This file is auto-generated by capybarish-gen.
"""

import struct
from dataclasses import dataclass, field, fields
from typing import Any, ClassVar, Dict, List, Optional, Tuple, Type, Union


# Helper functions for nested type serialization
def _flatten_nested(obj: Any) -> List:
    """Flatten a nested dataclass to a list of primitive values."""
    values = []
    for f in fields(obj):
        val = getattr(obj, f.name)
        if hasattr(val, '__dataclass_fields__'):
            values.extend(_flatten_nested(val))
        elif isinstance(val, list) and val and hasattr(val[0], '__dataclass_fields__'):
            for item in val:
                values.extend(_flatten_nested(item))
        elif isinstance(val, list):
            values.extend(val)
        else:
            values.append(val)
    return values


def _unflatten_nested(cls: Type, values: Tuple, start_idx: int = 0) -> Tuple[Any, int]:
    """Reconstruct a nested dataclass from a flat tuple of values."""
    obj = cls()
    idx = start_idx
    for f in fields(obj):
        field_type = f.type
        # Handle string type annotations
        if isinstance(field_type, str):
            field_type = globals().get(field_type, field_type)
        # Check if it's a nested dataclass by checking default_factory
        if f.default_factory is not type(None) and hasattr(f.default_factory, '__self__'):
            # It's a nested type
            nested_cls = f.default_factory.__self__.__class__
            nested_obj, idx = _unflatten_nested(nested_cls, values, idx)
            setattr(obj, f.name, nested_obj)
        elif hasattr(field_type, '__dataclass_fields__'):
            nested_obj, idx = _unflatten_nested(field_type, values, idx)
            setattr(obj, f.name, nested_obj)
        else:
            setattr(obj, f.name, values[idx])
            idx += 1
    return obj, idx


# Motor command sent from server to robot module
@dataclass
class ReceivedData:
    """Message type: ReceivedData."""

    _FORMAT: ClassVar[str] = 'ffffiiiif'
    _SIZE: ClassVar[int] = 36

    target: float = 0.0  # Target position (radians)
    target_vel: float = 0.0  # Target velocity (rad/s)
    kp: float = 0.0  # Proportional gain
    kd: float = 0.0  # Derivative gain
    enable_filter: int = 0  # Enable low-pass filter (0 or 1)
    switch_: int = 0  # Motor switch state (0=off, 1=on)
    calibrate: int = 0  # Trigger calibration (0 or 1)
    restart: int = 0  # Trigger restart (0 or 1)
    timestamp: float = 0.0  # Command timestamp (seconds)

    def serialize(self) -> bytes:
        """Serialize message to bytes."""
        return struct.pack(self._FORMAT, self.target, self.target_vel, self.kp, self.kd, self.enable_filter, self.switch_, self.calibrate, self.restart, self.timestamp)

    @classmethod
    def deserialize(cls, data: bytes) -> 'ReceivedData':
        """Deserialize message from bytes."""
        if len(data) < cls._SIZE:
            raise ValueError(f"Buffer too small: {len(data)} < {cls._SIZE}")
        values = struct.unpack(cls._FORMAT, data[:cls._SIZE])
        obj = cls()
        obj.target = values[0]
        obj.target_vel = values[1]
        obj.kp = values[2]
        obj.kd = values[3]
        obj.enable_filter = values[4]
        obj.switch_ = values[5]
        obj.calibrate = values[6]
        obj.restart = values[7]
        obj.timestamp = values[8]
        return obj

    @classmethod
    def size(cls) -> int:
        """Get serialized size in bytes."""
        return cls._SIZE


# IMU orientation (Euler angles in radians)
@dataclass
class IMUOrientation:
    """Message type: IMUOrientation."""

    _FORMAT: ClassVar[str] = 'fff'
    _SIZE: ClassVar[int] = 12

    x: float = 0.0  # Roll
    y: float = 0.0  # Pitch
    z: float = 0.0  # Yaw

    def serialize(self) -> bytes:
        """Serialize message to bytes."""
        return struct.pack(self._FORMAT, self.x, self.y, self.z)

    @classmethod
    def deserialize(cls, data: bytes) -> 'IMUOrientation':
        """Deserialize message from bytes."""
        if len(data) < cls._SIZE:
            raise ValueError(f"Buffer too small: {len(data)} < {cls._SIZE}")
        values = struct.unpack(cls._FORMAT, data[:cls._SIZE])
        obj = cls()
        obj.x = values[0]
        obj.y = values[1]
        obj.z = values[2]
        return obj

    @classmethod
    def size(cls) -> int:
        """Get serialized size in bytes."""
        return cls._SIZE


# IMU quaternion representation
@dataclass
class IMUQuaternion:
    """Message type: IMUQuaternion."""

    _FORMAT: ClassVar[str] = 'ffff'
    _SIZE: ClassVar[int] = 16

    x: float = 0.0
    y: float = 0.0
    z: float = 0.0
    w: float = 0.0

    def serialize(self) -> bytes:
        """Serialize message to bytes."""
        return struct.pack(self._FORMAT, self.x, self.y, self.z, self.w)

    @classmethod
    def deserialize(cls, data: bytes) -> 'IMUQuaternion':
        """Deserialize message from bytes."""
        if len(data) < cls._SIZE:
            raise ValueError(f"Buffer too small: {len(data)} < {cls._SIZE}")
        values = struct.unpack(cls._FORMAT, data[:cls._SIZE])
        obj = cls()
        obj.x = values[0]
        obj.y = values[1]
        obj.z = values[2]
        obj.w = values[3]
        return obj

    @classmethod
    def size(cls) -> int:
        """Get serialized size in bytes."""
        return cls._SIZE


# IMU angular velocity (rad/s)
@dataclass
class IMUOmega:
    """Message type: IMUOmega."""

    _FORMAT: ClassVar[str] = 'fff'
    _SIZE: ClassVar[int] = 12

    x: float = 0.0
    y: float = 0.0
    z: float = 0.0

    def serialize(self) -> bytes:
        """Serialize message to bytes."""
        return struct.pack(self._FORMAT, self.x, self.y, self.z)

    @classmethod
    def deserialize(cls, data: bytes) -> 'IMUOmega':
        """Deserialize message from bytes."""
        if len(data) < cls._SIZE:
            raise ValueError(f"Buffer too small: {len(data)} < {cls._SIZE}")
        values = struct.unpack(cls._FORMAT, data[:cls._SIZE])
        obj = cls()
        obj.x = values[0]
        obj.y = values[1]
        obj.z = values[2]
        return obj

    @classmethod
    def size(cls) -> int:
        """Get serialized size in bytes."""
        return cls._SIZE


# IMU linear acceleration (m/s²)
@dataclass
class IMUAcceleration:
    """Message type: IMUAcceleration."""

    _FORMAT: ClassVar[str] = 'fff'
    _SIZE: ClassVar[int] = 12

    x: float = 0.0
    y: float = 0.0
    z: float = 0.0

    def serialize(self) -> bytes:
        """Serialize message to bytes."""
        return struct.pack(self._FORMAT, self.x, self.y, self.z)

    @classmethod
    def deserialize(cls, data: bytes) -> 'IMUAcceleration':
        """Deserialize message from bytes."""
        if len(data) < cls._SIZE:
            raise ValueError(f"Buffer too small: {len(data)} < {cls._SIZE}")
        values = struct.unpack(cls._FORMAT, data[:cls._SIZE])
        obj = cls()
        obj.x = values[0]
        obj.y = values[1]
        obj.z = values[2]
        return obj

    @classmethod
    def size(cls) -> int:
        """Get serialized size in bytes."""
        return cls._SIZE


# Complete IMU data package
@dataclass
class IMUData:
    """Message type: IMUData."""

    _FORMAT: ClassVar[str] = 'fffffffffffff'
    _SIZE: ClassVar[int] = 52

    orientation: IMUOrientation = field(default_factory=IMUOrientation)
    quaternion: IMUQuaternion = field(default_factory=IMUQuaternion)
    omega: IMUOmega = field(default_factory=IMUOmega)
    acceleration: IMUAcceleration = field(default_factory=IMUAcceleration)

    def serialize(self) -> bytes:
        """Serialize message to bytes."""
        values = _flatten_nested(self)
        return struct.pack(self._FORMAT, *values)

    @classmethod
    def deserialize(cls, data: bytes) -> 'IMUData':
        """Deserialize message from bytes."""
        if len(data) < cls._SIZE:
            raise ValueError(f"Buffer too small: {len(data)} < {cls._SIZE}")
        values = struct.unpack(cls._FORMAT, data[:cls._SIZE])
        obj, _ = _unflatten_nested(cls, values)
        return obj

    @classmethod
    def size(cls) -> int:
        """Get serialized size in bytes."""
        return cls._SIZE


# Motor sensor data
@dataclass
class MotorData:
    """Message type: MotorData."""

    _FORMAT: ClassVar[str] = 'ffffffiii'
    _SIZE: ClassVar[int] = 36

    pos: float = 0.0  # Current position (radians)
    large_pos: float = 0.0  # Unwrapped position (radians)
    vel: float = 0.0  # Current velocity (rad/s)
    torque: float = 0.0  # Current torque (Nm)
    voltage: float = 0.0  # Motor voltage (V)
    current: float = 0.0  # Motor current (A)
    temperature: int = 0  # Temperature (°C)
    error0: int = 0  # Error code 0 (mode & error)
    error1: int = 0  # Error code 1

    def serialize(self) -> bytes:
        """Serialize message to bytes."""
        return struct.pack(self._FORMAT, self.pos, self.large_pos, self.vel, self.torque, self.voltage, self.current, self.temperature, self.error0, self.error1)

    @classmethod
    def deserialize(cls, data: bytes) -> 'MotorData':
        """Deserialize message from bytes."""
        if len(data) < cls._SIZE:
            raise ValueError(f"Buffer too small: {len(data)} < {cls._SIZE}")
        values = struct.unpack(cls._FORMAT, data[:cls._SIZE])
        obj = cls()
        obj.pos = values[0]
        obj.large_pos = values[1]
        obj.vel = values[2]
        obj.torque = values[3]
        obj.voltage = values[4]
        obj.current = values[5]
        obj.temperature = values[6]
        obj.error0 = values[7]
        obj.error1 = values[8]
        return obj

    @classmethod
    def size(cls) -> int:
        """Get serialized size in bytes."""
        return cls._SIZE


# System error data
@dataclass
class ErrorData:
    """Message type: ErrorData."""

    _FORMAT: ClassVar[str] = 'ii'
    _SIZE: ClassVar[int] = 8

    reset_reason0: int = 0  # CPU0 reset reason
    reset_reason1: int = 0  # CPU1 reset reason

    def serialize(self) -> bytes:
        """Serialize message to bytes."""
        return struct.pack(self._FORMAT, self.reset_reason0, self.reset_reason1)

    @classmethod
    def deserialize(cls, data: bytes) -> 'ErrorData':
        """Deserialize message from bytes."""
        if len(data) < cls._SIZE:
            raise ValueError(f"Buffer too small: {len(data)} < {cls._SIZE}")
        values = struct.unpack(cls._FORMAT, data[:cls._SIZE])
        obj = cls()
        obj.reset_reason0 = values[0]
        obj.reset_reason1 = values[1]
        return obj

    @classmethod
    def size(cls) -> int:
        """Get serialized size in bytes."""
        return cls._SIZE


# Complete sensor data from robot module
@dataclass
class SentData:
    """Message type: SentData."""

    _FORMAT: ClassVar[str] = 'iiiififfffffiiifffffffffffffii'
    _SIZE: ClassVar[int] = 120

    module_id: int = 0  # Unique module identifier
    receive_dt: int = 0  # Receive processing time (µs)
    timestamp: int = 0  # Current timestamp (µs)
    switch_off: int = 0  # Switch off request flag
    last_rcv_timestamp: float = 0.0  # Last received command timestamp
    info: int = 0  # Info/status code
    motor: MotorData = field(default_factory=MotorData)  # Motor sensor data
    imu: IMUData = field(default_factory=IMUData)  # IMU sensor data
    error: ErrorData = field(default_factory=ErrorData)  # Error/reset data

    def serialize(self) -> bytes:
        """Serialize message to bytes."""
        values = _flatten_nested(self)
        return struct.pack(self._FORMAT, *values)

    @classmethod
    def deserialize(cls, data: bytes) -> 'SentData':
        """Deserialize message from bytes."""
        if len(data) < cls._SIZE:
            raise ValueError(f"Buffer too small: {len(data)} < {cls._SIZE}")
        values = struct.unpack(cls._FORMAT, data[:cls._SIZE])
        obj, _ = _unflatten_nested(cls, values)
        return obj

    @classmethod
    def size(cls) -> int:
        """Get serialized size in bytes."""
        return cls._SIZE


# Message registry for dynamic lookup
MESSAGE_TYPES: Dict[str, type] = {
    "ReceivedData": ReceivedData,
    "IMUOrientation": IMUOrientation,
    "IMUQuaternion": IMUQuaternion,
    "IMUOmega": IMUOmega,
    "IMUAcceleration": IMUAcceleration,
    "IMUData": IMUData,
    "MotorData": MotorData,
    "ErrorData": ErrorData,
    "SentData": SentData,
}


def get_message_type(name: str) -> Optional[type]:
    """Get message class by name."""
    return MESSAGE_TYPES.get(name)